#' Merge Results
#' 
#' This merges result tables generated by DEseq. It can further filter the data
#' based on a user's chosen significance number. 
#'
#' @param agg_lst a list of results tibbles generated by DEseq
#' @param filter TRUE/FALSE that tells function whether you want to filter out
#'               certain rows. Set to true by default
#' @param thres a value to check for significance with. Default is 0.05
#'
#' @return a merged result table
#' @export
#'
#' @examples
merge_results <- function(agg_lst, filter = FALSE, thres = 0.05){
    #modifies list 
    ag <- agg_lst
        
    #checks length
    if (length(agg_lst) > 1){
        
        #error marker
        diff_cnts_flag <- FALSE
        
        #checks to see is all row counts are the same
        for (clustA in agg_lst[1:(length(agg_lst) - 1)]) {
            for (clustB in agg_lst[2:length(agg_lst)]){
                if (nrow(clustA) != nrow(clustB)){
                  diff_cnts_flag <- TRUE
                }
            }
        }
        
        #error thrown to stop potential errors
        if (diff_cnts_flag){
            stop("List '", deparse(substitute(agg_lst)), "' has tibbles with ",
                 "different row counts.\n  ", 
                 "Please use a function like 'prep_merge' to ensure rows are all same",
                 "number\n")
        }
        
        
        
        #list performs a bit funky with odd numbered lists, this prevents small issues
        #that can occur because of that
        odd <- FALSE
        if (length(ag) %% 2 == 1){
            ag[["dupe"]] <- ag[[1]]
            odd <- TRUE
        }
        
        #loops through list and merges
        for (i in 1:(length(ag) - 1)){
            ag[[2]] <- merge(ag[[1]], ag[[2]], 
                             by='gene', all=TRUE, 
                             no.dups = TRUE,
                             suffixes=c(paste("_", names(ag)[1], sep = ""),
                                        paste("_", names(ag)[2], sep = "")))
            ag <- ag[-1]
        }
        
        #removes extra column created so merging isn't funky
        if(odd){
            ag[[1]] <- ag[[1]][!(str_detect(names(ag[[1]]), "dupe"))]
        }
        
        aggr <- ag[[1]]
    }
    else {
        aggr <- as.data.frame(agg_lst[[1]])
    }
    
    #marks rows 
    rownames(aggr) <- as.data.frame(ag[[1]])[, "gene"]
    aggr <- aggr[, colnames(aggr) != "gene"] 
    
    #filters data if user wants it to be done
    if (filter){
        #creates new column
        aggr$keep <- FALSE
        
        #marks significant rows as TRUE
        for (name in names(aggr)[str_detect(names(aggr), "padj")]){
            aggr$keep[aggr[, name] < thres] <- TRUE
        }
        
        #removes unmarked rows
        aggr <- aggr[aggr$keep, ]
        
        #small check
        cat("There should be a TRUE under this line\n",
            !(FALSE %in% aggr$keep), "\n", sep = "")
        
        #removes extra col
        aggr <- aggr[, colnames(aggr) != "keep"] 
    }
    
    #returns the big table as data frame
    return(aggr)
}

---
title: "Pseudobulk vs MAST"
author: "Katherine Savell"
date: "2023-02-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
#Intro
Learned from https://hbctraining.github.io/scRNA-seq/lessons/pseudobulk_DESeq2_scrnaseq.html Thanks!

# Load packages

```{r message = FALSE}
library(Seurat)
library(tidyverse)
library(cowplot)
library(Matrix.utils)
library(edgeR)
library(dplyr)
library(magrittr)
library(Matrix)
library(purrr)
library(reshape2)
library(tibble)
library(pheatmap)
library(png)
library(DESeq2)
library(RColorBrewer)
library(MAST)


#set parallel conditions, do 1/2 or n - 2 the number of cores you have
plan('multisession', 
     workers = 3)
```

```{r}
Idents(glut.subset2) <- 'seurat_clusters'
DefaultAssay(glut.subset2) <- 'RNA'

glut.subset2$cluster_group <- paste(glut.subset2$seurat_clusters, 
                                    glut.subset2$group, 
                                    sep = "_")
```

# DESeq2 on aggregated data
```{r}

# create a metadata table
coldata <- colnames(pseudo.merge)

coldata <- data.frame(colnames(pseudo.merge),
                      condition = c("negative", "negative","negative","negative",
                                        "positive", "positive","positive","positive"))

# create a DESeqDataSet object
  dds <- DESeqDataSetFromMatrix(pseudo.merge, 
                                colData = coldata, 
                                design = ~ condition)

# perform quality control and filter out low-count genes
dds <- dds[ rowSums(counts(dds)) > 10, ]

# normalize the counts using DESeq's median-of-ratios method
dds <- estimateSizeFactors(dds)

vsd <- varianceStabilizingTransformation(dds, blind = FALSE)

rld <- rlog(dds, blind=FALSE)
plotPCA(rld) #to plot a simple PCA

# Heatmap and hierarchical clustering with Euclidean distances
sampleDists <- dist(t(assay(rld))) 
library(RColorBrewer)
library(pheatmap)
sampleDistMatrix <- as.matrix(sampleDists)
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDists,
         clustering_distance_cols=sampleDists,
         col=colors)

# fit the model
dds <- DESeq(dds)


# extract log2 fold changes and p-values
res <- results(dds)

res.df <- as.data.frame(res)

write.csv(res.df, '/Users/savellke/Documents/Analysis/mm10_exp1/bulkDESeqGlut.csv')

# plot log2 fold changes vs. mean expression
ggplot2::ggplot(res.df, aes(x = log2FoldChange, y = -log(padj))) +
  geom_point(alpha = 0.3) +
  ggtitle("DESeq analysis") +
  xlab("Log2 fold change") +
  ylab("Adjusted p-value")

```

#### Following https://hbctraining.github.io/scRNA-seq/lessons/pseudobulk_DESeq2_scrnaseq.html steps

# Set up SingleCellExperiment object
```{r}
# Extract raw counts and metadata to create SingleCellExperiment object
counts <- glut.subset2@assays$RNA@counts 

metadata <- glut.subset2@meta.data

# Set up metadata as desired for aggregation and DE analysis
metadata$cluster_id <- factor(glut.subset2@active.ident)

# Create single cell experiment object
sce <- SingleCellExperiment(assays = list(counts = counts), 
                           colData = metadata)

# Identify groups for aggregation of counts
groups <- colData(sce)[, c("cluster_id", "ratID", "group")]

```

```{r}
# Named vector of cluster names
kids <- names(table(sce$cluster_id))
kids

# Total number of clusters
nk <- length(kids)
nk

# Named vector of sample names
sids <- names(table(sce$ratID))
sids

# Total number of samples 
ns <- length(sids)
ns

# Named vector of sample names
gids <- names(table(sce$group))
gids

# Total number of samples 
ng <- length(gids)
ng
```
# Generate sample level metadata
```{r}
## Determine the number of cells per sample
table(sce$ratID)

## Turn named vector into a numeric vector of number of cells per sample
n_cells <- as.numeric(table(sce$ratID))

## Determine how to reorder the samples (rows) of the metadata to match the order of sample names in sids vector
m <- match(sids, sce$ratID)

## Create the sample level metadata by combining the reordered metadata with the number of cells corresponding to each sample.
ei <- data.frame(colData(sce)[m, ], 
                  n_cells, row.names = NULL) %>% 
                select(-"cluster_id")
ei
```
# Aggregate the counts per sample_id and cluster_id
```{r}
# Subset metadata to only include the cluster and sample IDs to aggregate across
groups <- colData(sce)[, c("cluster_id", "group","ratID")]

# Aggregate across cluster-sample groups
pb <- aggregate.Matrix(t(counts(sce)), 
                       groupings = groups, fun = "sum") 

class(pb)

dim(pb)

pb[1:6, 1:6]
```

##STUCK HERE
```{r}
# Not every cluster is present in all samples; create a vector that represents how to split samples
splitf <- stringr::str_split(rownames(pb), 
                                    pattern = "_",  
                                    n = 3) #changed this, got rid of the sapply

# Turn into a list and split the list into components for each cluster and transform, so rows are genes and columns are samples and make rownames as the sample IDs
pb <- split.data.frame(pb, 
                       factor(splitf)) %>%
        lapply(function(u) 
                set_colnames(t(u), 
                             stringr::str_extract(rownames(u), "(?<=_)[:alnum:]+")))

class(pb)
```

```{r}
table(sce$cluster_id, sce$group, sce$ratID)
```

##DESeq2
#Prep
```{r}
# Get sample names for each of the cell type clusters

# prep. data.frame for plotting
get_sample_ids <- function(x){
        pb[[x]] %>%
                colnames()
}

de_samples <- map(1:length(kids), get_sample_ids) %>%
        unlist()

# Get cluster IDs for each of the samples

samples_list <- map(1:length(kids), get_sample_ids)

get_cluster_ids <- function(x){
        rep(names(pb)[x], 
            each = length(samples_list[[x]]))
}

de_cluster_ids <- map(1:length(kids), get_cluster_ids) %>%
        unlist()
```

